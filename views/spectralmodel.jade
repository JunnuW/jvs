//-Created by Juha on 3/7/2016.
extends broaden
block levenee
    div(id='wrapper')
      div(id='main')
        br
        //a(href="#page2show" class = "ui-content" data-rel="dialog") page2
        //a(href="/el_dialog?huuhaa=1") page2
        h3(id='inhomHeader') Simulation for inhomogeneous broadening
        |   Calculated spectra are obtained using equation (2) on the
        -equation2="/inhomogen"
        a(href="#{equation2}" target="_blank")     Inhomogeneous details
        |    page. (Used to evaluate the broken line curves on that page.)
        br
        //div(class="ui-content")
          -tialooki="/multi-page"
          a(href="#{tialooki}") Open dialog
        br
        div(id="footer" style="paddig-left:50px")
          Copyright &copy; 2007 - 2014 IOLA and Ole Laursen :
        //div(id="content")
          //this contains the playground for the simulation graph
        div(class="demo-container")
          //div(id="ph1_inhomog" class="demo-placeholder")
          div(id="ph1_inhomog" target="_blank" class="demo-placeholder")
        b(id='inhDescLbl' style='color:Brown') Measurement details:
        b(id='inhDesc' style="color:Indigo; margin-left:10px;")

        h3 Simulation for homogeneous broadening
        |   Calculated spectra are obtained using equation (x) on the
        -equation3="/homogen"
        a(href="#{equation3}" target="_blank")     Homogeneous details
        |    page.
        div(id="content2")
          //this contains the playground for the simulation graph
          div(class="demo-container")
            div(id="ph2_homog" class="demo-placeholder")
          b(id='homDescLbl' style='color:Brown') Measured details:
          b(id='homDesc' style="color:Indigo; margin-left:10px;")
        //-img(id="huuhaa" src="" alt="Tallennettava kuva" width="42" height="42")
        //-flot graph 0.8.3 versiossa canvas ei sisällä akselien tekstejä eikä
        //-käyrien captioneja. Nämä on luvattu vasta 0.9. versioon
        //-Ei kannata satsata eforttia kuvan copy-paste rutiiniin canvaksesta ennen sitä.


    //div(id="page2show" data-role="page")
      div(data-role="header")
        h2 Dialog
      div(role="main" class="ui-content")
        p I am a dialog

    div(id="settnDial" title="Graphing details")
      //- x-axis: spectral range settings
      fieldset(id='spRange' style='display:none')
        b(style='font-size:16px') Spectral range [eV's]:
        button(id='rangeok' class='medium-btn2') OK
        //label(for="eVStart") Starts at:
        //input(id="eVStart" name="eVStart" class='inputti')
        //label(for="eVStop") Stops at:
        //input(id="eVStop" name="eVStop" class='inputti')
        //button(id='rangeok' style="margin:0px 15px") OK
        br
        table(style="width:500px;")
          tr
            td(class='huihai')
              b Starts at:
              br
              input(id="eVstart_touch" name="eVStart_touch" class="form-control input-sm")
            td(class='huihai')
              b Stops at:
              br
              input(id="eVstop_touch" name="eVStop_touch" class="input-sm")

        //div(class="input-sm col-md-4")
      //-Boltzmann distribution for energy occupancy:
      fieldset(id='eg_et' style='display:none')
        b(style='font-size:16px') Energy state occupancy: \(f_{cv}=f_{c}(\epsilon)\times(1-f_{v}(\epsilon))\)
        |   is approximated
        br
        | with Bolzmann distribution: \(f_{B}=exp(-\epsilon/k_{B}T)\), where \(\epsilon > E_{t}\)
        br
        b Minimum transition energy [eV]
        i   (for bulk materials \(E_{t}=E_{g}\) )
        br
        br
        label(for="eV_Et" class='eV_Et-label') Et:
        button(id='Et_down' style="margin:0px 0px") -
        input(id="eV_Et" class='spinneri')
        button(id='Et_up' style="margin:0px 0px") +
        label(for="tempK" class='temp-label') Temp [K]:
        button(id='T_down' style="margin:0px 0px") -
        input(id="tempK" class='spinneri')
        button(id='T_up' style="margin:0px 0px") +
        button(id='evetok' style="margin-left:40px") OK
      //- Joint density of states:
      fieldset(id='spJdos' style='display:none')
        b(style='font-size:16px') Joint density of states (JDOS):
        br
        input(type="radio" id="bulkJDOS" name="jdos" value="bulk" style="margin-left:5px")
        |   Bulk-JDOS
        i   (\(\rho_{r}\propto \sqrt{\epsilon-E_{t}}\))
        br
        input(type="radio" id="qwJDOS" name="jdos" value="qw" style="margin-left:5px")
        |   QW-JDOS
        i   (Heaviside step function)
        button(id='jdosok' style="margin:0px 35px") OK

      //-Exciton enhancement:
      fieldset(id="exEnha" style='display:none')
        b(id='bulklege' class='otsikko') Exciton enhancement for bulk material
        i(id='bulk_i' style='display:none')   ( 3D-exciton model )
        b(id='qwlege' class='otsikko') Eciton enhancement for QW-material
        i(id='qw_i' style='display:none')   ( 2D-exciton model )
        //-br
        //-p(id='bulklege' style='display:none')   For bulk materials (3D-excitons)
        //p(id='qwlege' style='display:none')     For qw-materials (2D-excitons)
        br
        div(id='qwendetls')
          div(style='font-size:16px')
            b Viewing direction:
              //-&nbsp; &nbsp; &nbsp;
              //-| Polarization:
            b(style='padding-left:60px') Polarization:
          div(id='qwenhas')
            label(for="dirPar") On qw plane:
            input(type="radio" id="dirPar" name="dirBut" value="parallel" checked="checked" style="margin-right:7px")
            label(for="enhTE") TE:
            input(type="radio" id="enhTE" name="enhBut" value="TE" checked="checked" style="margin-right:7px")
            //-| TE-polarization
            br
            label(for="dirPerp") On qw normal:
            input(type="radio" id="dirPerp" name="dirBut" value="perpend" style="margin-right:7px")
            label(for="enhTM") TM:
            input(type="radio" id="enhTM" name="enhBut" value="TM" style="margin-right:7px")
        br
        //- b(id='exBndLbl' class='boldsFrmt') Exciton binding energy [meV]:
        label(for="eV_Bind" class='label3') \(\mathbf{E_{b}}\) [meV]:
        input(id="eV_Bind" name="eV_Bind" class='inputti')
        label(id="lbl_eV0" for="eV_0" class="label4" style="display:none") Shape param [meV]:
        input(id="eV_0" name="eV_0" class='inputti' style="display:none")
        button(id='exenhaok' style="margin:0px 10px") OK

      fieldset(id='spUrbach' style='display:none')
        b(style='font-size:16px') Asymmetric Urbach tail
        br
        i Inhomogeneous broadening for populations with exponential energy distributions
        i   (plotted alone if no plotting selections)
        br
        b Line shape:
        br
        i       \(L_{ih}(\epsilon)=\frac{1}{2}(1-sgn(E_{f}-\epsilon))\cdot\exp[-(E_{f}-\epsilon)/E_{u}]\)
        br
        i Here \(E_{f}=E_{t}\quad\)  (for adjustment apply the transition energy option)
        br
        b Broadening parameter [meV]
        br
        label(for="eveu") \(E_{u}\):
        input(id="eveu" class="inputti")
        button(id='urbachok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spSurbach' style='display:none')
        b(style='font-size:16px') Symmetric Urbach tail
        br
        i Inhomogeneous broadening for populations with exponential energy distributions
        i   (plotted alone if no plotting selections)
        br
        b Line shape:
        br
        i       \(L_{ih}(\epsilon)=\exp[-|E_{f}-\epsilon|/E_{u}]\)
        br
        i Here \(E_{f}=E_{t}\quad\)  (for adjustment apply the transition energy option)
        br
        b Broadening parameter [meV]
        br
        label(for="evSeu") \(E_{u}\):
        input(id="evSeu" class="inputti")
        button(id='sUrbachok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spLorentz' style='display:none')
        b(style='font-size:16px') Lorentzian function
        br
        i Homogeneous broadening with
        br
        b Line shape: \(\ L_{t}(\Delta E)=\frac{\tau_{r}/(\pi\hbar)}{1+\tau_{r}^{2}\Delta E^{2}/\hbar^{2}}\)
        br
        label(for="tauR" class='label2') Relaxation time \(\mathbf{\tau_{r}}\) [fs]:
        input(id="tauR" class="inputti")
        button(id='lorentzok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spDlorentz' style='display:none')
        //if user clicks on Dlorentz title this becomes visible
        b(style='font-size:16px') Product of two Lorentzians
        br
        i Homogeneous broadening with
        br
        b Line shape:
        br
        | \(\ L_{t}(\Delta E)= \frac{(\tau_{be}+\tau_{bh})/(\pi\hbar)}{1+\tau_{be}^{2}
        | \Delta E^{2}/\hbar^{2}}\times\frac{1}
        | {1+\tau_{bh}^{2}\Delta E^{2}/\hbar^{2}}\)
        br
        b Relaxation times [fs]:
        br
        label(for="tauBe")  \(\tau_{be}\):
        input(id="tauBe" class="inputti")
        label(for="tauBh") \(\tau_{bh}\):
        input(id="tauBh" class="inputti")
        button(id='dlorentzok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spGaussian' style='display:none')
        //if user clicks on Dlorentz title this becomes visible
        b(style='font-size:16px') Gaussian function
        br
        i Inhomogeneous broadening for populations with Gaussian energy distribution. (or non-Markovian homogeneous
          | populations)
        br
        b Line shape:
        br
        | \(\ L_{ih}(\Delta E)=\frac{1}{\sigma\sqrt{2\pi}}exp(-\frac{\Delta E^{2}}{2\sigma^{2}})\)
        br
        b Broadening parameter [meV]:
        br
        label(for="gauSig")  \(\sigma\):
        input(id="gauSig" class="inputti")
        button(id='gaussianok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spSech' style='display:none')
        //if user clicks on Dlorentz title this becomes visible
        b(style='font-size:16px') Spectral broadening from \(Sech^{n}\) time relaxation
        br
        i A non-Markovian relaxation time function for the e-h pair population is given without descriptions of its origin.
          | (i.e. proposed ad hoc to explain the non-Lorentzian line shapes from qw-emitters)
        br
        b Line shape:
        br
        | \(\ L_{t}(\Delta E)=\mathfrak{F}[sech^{n}(\frac{t}{\tau \times n})]\),
        br
        | where \(\mathfrak{F}\)  stands for Fourier transform. Sech is the hyperbolic secant function and \(\tau\ \) the
        | relaxation time.
        br
        b Broadening parameters:
        br
        label(for="sechN")  \(Power\ n\):
        input(id="sechN" class="inputti")
        label(for="sechTau")  \(\tau\ [fs]:\)
        input(id="sechTau" class="inputti")
        button(id='sechok' style="margin:0px 15px") OK
        br
        i (Applied as convolution kernel, if selected with 'Plotting selector' items)

      fieldset(id='spWhat' style='display:none')
        b(id='bPlotSel' style='font-size:16px') Plotting selector for: `\int_0^\infty \epsilon\rho_{r}
          |(\epsilon)S(\epsilon)exp(-\epsilon/k_{B}T)\times L_{ih}(E-\epsilon)\quad d\epsilon`
        br
        //i(style='float:right')    (click selection titles to edit parameters)
        i(style='float:left')    (click selector titles to edit parameters)
        br
        //-legend(style="font-size:100%") Plotting selector
        div(id='divEpsilon' style='display:none')
          input(id="pltEpsilon" style='margin-left:7px' type="checkbox" value='No')
          //-p(style='padding-left:30px') Photon energy: \(\epsilon\)
          //prevent scrolling to top of link page by using: javascript:void(0);
          a(href="javascript:void(0)", id="hrefEpsilon", style='padding-left:30px')
            | Photon energy, \(\epsilon\)
            span(style="color:brown;")    (set range in [eV])
        div(id='divJdos' style='display:none')
          input(id="pltJdos" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefJdos", style='padding-left:30px')
            | Joint Density of States,  \(\rho_{r}\)
            span(style="color:brown;")    (select bulk or QW model)
        div(id='divSommerf' style='display:none')
          input(id="pltSommerf" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefSommerf", style='padding-left:30px')
            | Sommerfeldt enhancement, \(S(\epsilon)\)
            span(style="color:brown;")    (set exiton parameters)
        div(id='divFcv' style='display:none')
          input(id="pltFcv" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefTransito", style='padding-left:30px')
            | Boltzmann distribution
            span(style="color:brown;")    (set transition energy, \(E_{t}\) and T in [K])
        b(id='bConvolOpt' style='font-size:16px') Broadening [Lih] options in the convolution integral:
        div(id='divUrbach' style='display:none')
          input(id="pltUrbach" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefUrbach", style='padding-left:30px')
            | Asymmetric Urbach tail
            span(style="color:brown;")    (set tail parameter \(E_{u}\))

        div(id='divSurbach' style='display:none')
          input(id="pltsUrbach" style='margin-left:7px' type="checkbox" value='No')
          //-hidden input for file name to open local file using HTML5 file API
          input(type="file" id="emisLocFiles" style="display:none" name="emisLocFiles")
          a(href="javascript:void(0)", id="hrefsUrbach", style='padding-left:30px')
            | Symmetric Urbach distribution
            span(style="color:brown;")     (set tail parameter \(E_{u}\))
        div(id='divLorentz' style='display:none')
          input(id="pltLorentz" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefLorentz", style='padding-left:30px')
           | Lorentzian line shape
           span(style="color:brown;")     (set broadening parameter \(\tau_{r}\))
        div(id='divDLorentz' style='display:none')
          input(id="pltDlorentz" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefdLorentz", style='padding-left:30px')
           | Product of Lorentzians line shape
           span(style="color:brown;")     (set broadening parameters \(\tau_{be}\) and \(\tau_{bh}\))
        div(id='divGaussian' style='display:none')
          input(id="pltGaussian" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefGaussian", style='padding-left:30px')
            | Gaussian line shape
            span(style="color:brown;")     (set broadening parameter \(\sigma \) )
        div(id='divSech' style='display:none')
          input(id="pltSech" style='margin-left:7px' type="checkbox" value='No')
          a(href="javascript:void(0)", id="hrefSech", style='padding-left:30px')
            | Sech function line shape
            span(style="color:brown;")     (set relaxation time, \(\tau\) and exponent, n )
        div(id='divHomogConv' style='display:none')
          input(id="pltHomConv" style='margin-left:7px' type="checkbox" value='No')
          i(style='padding-left:30px')
            |  Calculate broadening (convolve) using selected lineshape
        div(id='divNormalize' style='display:none')
          input(id="pltNormalize" style='margin-left:7px' type="checkbox" value='No')
          i(style='padding-left:30px')
            |  Normalize spectrum to unity peak value
        div

      br
      button(id='openFile' style="margin:0px 5px") Open file
      button(id='saveFile' style="margin:0px 5px") Save file
      //-button(id='saveFile' style="display:none") Save file


    include mongoDialForm
    //-correct indenting is required

    //-*****************************************************************************/
    style(type = "text/css").
      /* Simulation graph placeholders*/
      .demo-placeholder {
        /*width: 600px;
        height: 400px;*/
        width: 820px;
        height: 430px;
        font-size: 14px;
        line-height: 1.2em;
      }

      /* Simulation graph containers*/
      .demo-container {
        box-sizing: border-box;
        width: 850px;
        height: 460px;
        padding: 20px 15px 15px 15px;
        margin: 15px auto 30px auto;
        border: 1px solid #ddd;
        background: #fff;
        background: linear-gradient(#f6f6f6 0, #fff 50px);
        background: -o-linear-gradient(#f6f6f6 0, #fff 50px);
        background: -ms-linear-gradient(#f6f6f6 0, #fff 50px);
        background: -moz-linear-gradient(#f6f6f6 0, #fff 50px);
        background: -webkit-linear-gradient(#f6f6f6 0, #fff 50px);
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
        -o-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        -ms-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        -moz-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        -webkit-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        margin-left: 10px;
      }

      /* Dialog box inputs*/
      .inputti {
        width: 45px;
        margin-left: 13px;
      }

      /* Dialog box inputs*/
      .spinneri {
        width: 45px;
      }

      /* Dialog box inputs*/
      .inputti2 {
        width: 45px;
        margin-left: 13px;
        text-align: left;
      }

      /* Dialog box fieldsets*/
      fieldset {
        border: 1px solid green;
        padding: 1em;
      }

      /* Dialog box labels*/
      label {
        width: 23%;
        margin-right: 5px;
        text-align: right;
        font-weight: bold;
      }

      /* Boltzmann distr Et label*/
      .eV_Et-label {
        width: 10%;
        margin-right: 5px;
        text-align: right;
        font-weight: bold;
      }

      /* Boltzmann distr temp label*/
      .temp-label {
        width: 17%;
        margin-right: 5px;
        text-align: right;
        font-weight: bold;
      }

      /* Dialog box fieldset titles*/
      .otsikko {
        font-size: 16px;
        display: none;
      }

      /* Dialog box fieldset labels*/
      .label2 {
        width: 40%;
        margin-right: 5px;
        text-align: right;
        font-weight: bold;
      }

      /* Dialog box fieldset labels*/
      .label3 {
        width: 15%;
        margin-right: 5px;
        text-align: left;
        font-weight: bold;
      }

      /* Dialog box fieldset labels*/
      .label4 {
        width: 32%;
        margin-right: 5px;
        margin-left: 15px;
        text-align: right;
        font-weight: bold;
      }

      /* Dialog box fieldset labels*/
      .label5 {
        width: 40%;
        margin-right: 5px;
        text-align: left;
        padding-left: 20px;
        font-weight: normal;
      }

      /* Dialog box fieldset labels*/
      .label6 {
        width: 30%;
        margin-right: 5px;
        text-align: left;
        padding-left: 20px;
        font-weight: normal;
      }

      .big-btn-left {
        width: 90px;
        height: 40px;
        float: left;
      }

      .big-btn-center {
        width: 120px;
        height: 50px;
        text-align: center;
        float: left;
        display: inline-block;
      }

      .big-btn {
        width: 120px;
        height: 50px;
        float: right;
      }

      .medium-btn-left {
        width: 120px;
        height: 30px;
        float: left;
      }

      .medium-btn-right {
        width: 120px;
        height: 30px;
        float: right;
      }

      /* button formatting in dialog form for directory selection: */
      .medium-btn {
        width: 120px;
        height: 30px;
        float: right;
        margin-right: 30px;
      }

      /* button formatting in dialog form for energy range accepting: */
      .medium-btn2 {
        width: 120px;
        height: 30px;
        float: right;
        margin-right: 100px;
      }

      /* not in use */
      .small-btn {
        width: 50px;
        height: 20px;
      }

      .huihai {
        padding-left:50px;
      }

      /* muuttaa dialogin vaaleankeltaiseksi
      .vaaleankelt {
        background: lightyellow !important;
      }*/


    //-******************************************************************************/
    //-******************************************************************************/

    script(type="text/javascript").
      var userName = 'No login';     // after login obtained from web-server
      var dirUser='Publ';            //default (i.e. No Login) username for server directory
      var kBoltz = 1.38064852E-23;   //Boltzmann constant
      var eCha = 1.60217662E-19;     //electron charge
      var hBar = 1.05457180E-34;     //reduced Planck constant hbar
      var hPlanck = 6.62607004E-34;  //Plank's constant [Js]
      var fftN = 2048;               //number of points in Cooley Tukey fft circular algorithm
      var inhomSpectr= new Object(); //spectrum simulation for inhomog. broadening plotting
      var homSpectr = new Object();  //spectrum simulation for homog. broadening plotting
      var simSettn = new Object();   //parameter values used in simulations and spectrum saving

      inhomSpectr.numPoints=1000;    //less than half of fftN (Nyquist sampling rate criterion)
      homSpectr.numPoints = inhomSpectr.numPoints;
      //simSettn.savePoints=1000;       //save all points, user can change it on saving dialog

      inhomSpectr.inPlot={
        eV:true,          //initially show only photon energy
        jdos:false,       //density of states not multiplied
        Se:false,         //Sommerfeld enhancement not multiplied
        fcv:false,        //Energy state occupancy not multiplied
        Lurb:false,       //One sided Urbach broadening not selected
        Lsurb:false,      //Symmetric Urbach broadening not selected
        Lgaus:false,      //Gaussian broadening not selected
        Lsech:false,      //Sech broadening function not selected
        convo:false       //convolution calculation not selected
      };

      homSpectr.inPlot = {
        convo: false,
        exper: false
        //inhom:false,
        //line:true
      };

      inhomSpectr.eVarr=[];              //photon energy array (x-axis points)
      inhomSpectr.jdosArr=[];            //jdos
      inhomSpectr.exenArr=[];            //exciton enhancement array
      inhomSpectr.fcvArr = [];           //boltzmann function array
      inhomSpectr.Lih = [];              //Lih array centre at Etr
      inhomSpectr.plotArr = [];          //plotted array
      inhomSpectr.experArr = [];         //Experimental spectrum as read from file
      inhomSpectr.experPlot = [];        //Experimental spectrum as scaled in plot
      homSpectr.plotArr = [];            //plotted on second figure
      homSpectr.experArr = [];           //experimental array as read from file
      homSpectr.experPlot = [];          //experimental array for plotting

      simSettn= {
        //++++++spectral range for calculations:
        eVstart: 1.3,           //start energy for simulation
        eVstop: 1.7,            //stop energy for simulation
        eTr: 1.4,               //Transition energy in Boltzmann function
        //Ev:true,
        //++++++Temperature in the Boltzmann energy distribution in the e-h pair population
        kelvin: 293,            //temperature [K] in boltzmann function
        //++++++Density of states, either; 'qw' for quantum wells or 'bulk' for bulk materials
        jdostype: "qw",         //bulk or qw: parabolic or Heaviside step function
        //++++++Exciton enhancement parameters for bulk and qw's:
        exEb: 5,                //exciton binding energy meV
        //++++++Exciton parameters for qw's:
        viewDir: 'parallel',    //viewing dir; on qw plane:'parallel', outside plane:'perpend'
        polarizat: 'TE',        //TE or TM, (TM possible only if viewed on qw plane)
        ex0: 2.0,               //exciton spectrum shape parameter meV; removes singularity at eTr
        //++++++Broadening function parameters:
        eU: 8,                  //Urbach energy, valid for both single- and two sided function [meV]
        GauSig: 7,              //variance [meV] in gaussian broadening
        SechTau: 100,           //tau for Sech fun broadening
        SechN: 1,               //exponent n for Sech fun broadening
        LorTau: 100,            //Lorentzian reduced relaxation time femtoseconds
        DlTau1: 100,            //electron/hole relaxation time in dual Lorentzian B.F. [fs]
        DlTau2: 100             //hole/electron relaxation time in dual Lorentzian B.F. [fs
      };

      graphSettn={
        inhomLegend: '',        //legend for graph 1
        homLegend: '',          //legend for graph 2
        inhomLinlog: 'lin',     //first plot linear or logarithmic
        homLinlog: 'log',       //second plot linear or logarithmic
        inhomFileN: '',         //filename for experimental file in inhom plot
        homFileN: ''            //filename for measurement in homogeneous plot
      };

      // Additional initial values *******************************************:
      // ****************************************************************
      makespArr();  //creates spectral points array and stores to inhomSpectr.eVarr
      var optiot = {//initial plotting options
        xaxes: [{position: 'bottom', axisLabel: 'Energy eV'}],
        yaxes: [{position: 'left', axisLabel: 'Relative Intensity'}],
        legend: {position: "ne"},
        grid: {//This one set can be hovered:
          margin: {
            top: 35
          },
          hoverable: 'Relative Intensity'
        },
          canvas: true
      };

      var plot = $.plot("#ph1_inhomog", [], optiot);
      var plot2 = $.plot("#ph2_homog", [], optiot);
      var dataa = [
        //initializes data for graph plotting
        {//only one x,y and axis pair
         //data: LinOrLog(inhomSpectr.plotArr),
          data: LinOrLogs(graphSettn.inhomLinlog,inhomSpectr.plotArr,plot),
            xaxis: 1, yaxis: 1, label: graphSettn.inhomLegend
        }
      ];

      /*if (window.sessionStorage.getItem('RTFtoken') && window.sessionStorage.getItem('RTFtoken').length > 0) {
          userName = window.sessionStorage.getItem('RTFuser');
      } else {
          userName = 'No login';
          dirUser = 'Publ';
          var fiile = 'Defaults/R-Default';
          mongoGetOne(fiile, dirUser);// opens default stack from Publ dierectory
      }*/


      function setQwRadio(){
        //console.log('setQwRadio');
        if (simSettn.viewDir == 'parallel'){
          $('#dirPar').prop('checked',true);
          $('#dirPerp').prop('checked',false);
        }else{
          $('#dirPar').prop('checked',false);
          $('#dirPerp').prop('checked',true);
        }
        if (simSettn.polarizat == 'TE') {
          $('#enhTE').prop('checked',true);
          $('#enhTM').prop('checked',false);
        }else{
          $('#enhTE').prop('checked',false);
          $('#enhTM').prop('checked',true);
        }
      }

      function setJdosRadio(){
        if (simSettn.jdostype == "bulk") {
          $('#bulkJDOS').prop("checked", true);
          $('#bulklege').css('display','inline');
          $('#bulk_i').css('display','inline');
          $('#qwlege').css('display','none');
          $('#qw_i').css('display','none');
          $('#qwendetls').css('display','none');
        } else {
          $('#qwJDOS').prop("checked", true);
          $('#bulklege').css('display','none');
          $('#bulk_i').css('display','none');
          $('#qwlege').css('display','inline');
          $('#qw_i').css('display','inline');
          $('#qwendetls').css('display','inline');
        }
      }

      makeJdos();       //density of states
      makeBoltz();      //creates Boltzmann distribution
      setChkboxes();    //updates checkbox status
      setLegend();      //makes plotting legend
      makeSommer();     //exciton enhanchements
      calcInhom();      //produce initial graph

      $("#settnDial").dialog({
        width:700,
        autoOpen: false,
        maxHeight: '700px',
        overflow: 'auto',
        show: {
          effect: "blind",
          duration: 500
        },
        hide: {
          effect: "explode",
          duration: 200
        }
      });

      //Build dialog form for opening and saving files
      var srvrFileTxt = 'Open emission spectrum';
      var DFmngo = $('#mongoDialForm'); //dialog form
      DFmngo.dialog('option', 'title', srvrFileTxt);

      $('#openFile').click(function(){
        //PL/EL emission spectrum from emission collection
        $('#settnDial').dialog('close');
        DFmngo
          .dialog('option','width','700px')
          .dialog('option','title',srvrFileTxt)
          .dialog('open');
        $('#frm-DirSel').show();
        $('#openOpti').css('display','inline');
      });

      $('#saveFile').click(function () {
        var otsake=$('#settnDial').dialog('option', 'title');
        if (otsake=='Inhomogeneous spectrum'){//simulation settings label adjustment:
          $('#lblsaveSimSpe').text("Inhomogeneous simulation");
        } else {
          $('#lblsaveSimSpe').text("Homogeneous simulation");
        }
        if ($('#chkSaveSimu').prop('checked')) {//check calculated value saving
            $('#numSel').prop('disabled',false);//enable datapoint count adjustment
        }else{
            $('#numSel').prop('disabled',true);
        }

        if ((homSpectr.experArr.length < 1 && otsake == 'Homogeneous spectrum') ||
              (inhomSpectr.experArr.length < 1 && otsake == 'Inhomogeneous spectrum')) {
          $('#chkSaveExper').attr('disabled',true); //no experimental inhom. or homogeneous data
        } else {
          $('#chkSaveExper').attr('disabled',false);//experimental data exists for saving
        }
        $('#settnDial').dialog('close');
        var srvrFileTxt = 'Save emission spectrum';

        DFmngo
          .dialog('option','width','700px')
          .dialog('option', 'title', srvrFileTxt)  // PL/EL emission spectrum db collection
          .dialog('open');
        $('#openOpti').css('display','none');
      });

      /*$("#ph1_inhomog").mousedown(function () {
          periodi = setInterval(inhomSettns_dialog, 700);
      }).mouseup(function () {
          clearInterval(periodi);
      }).mouseout(function () {
          clearInterval(periodi);
      });*/

      function inhomSettns_dialog(){
          $('#spWhat').css('display', 'block');
          $('#spLorentz').css('display', 'none');
          $('#spDlorentz').css('display', 'none');
          $('#bConvolOpt').text('Broadening (convolution) options for Lih:');
          $('#divEpsilon').css('display', 'block');
          $('#divJdos').css('display', 'block');
          $('#divSommerf').css('display', 'block');
          $('#divFcv').css('display', 'block');
          $('#divUrbach').css('display', 'block');
          $('#divSurbach').css('display', 'block');
          $('#divGaussian').css('display', 'block');
          $('#divSech').css('display', 'block');
          $('#divLorentz').css('display', 'none');
          $('#divDLorentz').css('display', 'none');
          $('#divHomogConv').css('display', 'none');
          //$('#divHomog').css('display', 'block');
          $('#divNormalize').css('display', 'block');
          $('#settnDial').dialog('option', 'title', 'Inhomogeneous spectrum');
          $("#settnDial").dialog("open");
          if (inhomSpectr.experArr.length > 0) {
              $('#saveFile').css('display', 'inline');
              //var srvrFileTxt = 'Save emission spectrum';
              //var DFmngo = $('#mongoDialForm'); //dialog form
              //DFmngo.dialog('option', 'title', srvrFileTxt);  // starts from LED collection
          } else {
              $('#saveFile').css('display', 'inline');
          }
          setJdosRadio();
          setQwRadio();
      }

      /*$("#ph1_inhomog").on("swipe", function () {
        inhomSettns_dialog();
      });*/

      /*$('#inhomHeader').on("swipe", function () {
          $(this).hide();
      });

      $('#inhomHeader').on("taphold", function () {
          $(this).hide();
      });*/

      /*$("#ph1_inhomog").on("taphold", function(event) {
        inhomSettns_dialog();
      });*/

      $('#ph1_inhomog').dblclick(function(){
        inhomSettns_dialog();
      });

      /*$("#ph2_homog").mousedown(function () {
          periodi = setInterval(homogSettns_dialog, 700);
      }).mouseup(function () {
          clearInterval(periodi);
      }).mouseout(function () {
          clearInterval(periodi);
      });*/

      function homogSettns_dialog(){
          $("#spSech").css('display', 'none');
          $("#spGaussian").css('display', 'none');
          $("#spSurbach").css('display', 'none');
          $("#spUrbach").css('display', 'none');
          $('#spWhat').css('display', 'block');
          $('#bConvolOpt').text('Homogeneous broadening options for Lh:');
          $('#divEpsilon').css('display', 'block');
          $('#divJdos').css('display', 'block');
          $('#divSommerf').css('display', 'block');
          $('#divFcv').css('display', 'block');
          $('#divUrbach').css('display', 'none');
          $('#divSurbach').css('display', 'none');
          $('#divGaussian').css('display', 'none');
          $('#divSech').css('display', 'none');
          $('#divLorentz').css('display', 'block');
          $('#divDLorentz').css('display', 'block');
          //$('#divHomog').css('display', 'block');
          $('#divHomogConv').css('display', 'block');
          $('#divNormalize').css('display', 'block');
          $('#settnDial').dialog('option', 'title', 'Homogeneous spectrum');
          $("#settnDial").dialog("open");
          if (homSpectr.experArr.length > 0) {
              $('#saveFile').css('display', 'inline');
          } else {
              $('#saveFile').css('display', 'inline');
          }
      }

      $('#ph2_homog').dblclick(function () {
        homogSettns_dialog();
      });

      $("#eVstart_touch").TouchSpin({
        max: simSettn.eVstop - 0.1,
        min: 0,
        step: 0.001,
        initval: simSettn.eVstart,
        decimals: 3,
        boostat: 10,
        maxboostedstep: 0.005,
        postfix: 'eV',
        mousewheel: true
      });

      $("#eVstart_touch").on('touchspin.on.stopspin', function (e) {
        //console.log('eVstart_touch: ', $("#eVstart_touch").val());
        var tmp1 = Number($("#eVstart_touch").val());
        simSettn.eVstart=tmp1.toFixed(3);
        console.log('eVstart: ',simSettn.eVstart);
        $('#eVStart').val(simSettn.eVstart);
        //prep. min value for eVstop_touch i.e. set 0.1eV minimum horiz. scale span:
        tmp1=tmp1+0.1;
        $("#eVstop_touch").trigger("touchspin.updatesettings", {min:tmp1});
      });

      $("#eVstop_touch").TouchSpin({
        max: 4.0,
        min: simSettn.eVstart + 0.1,
        step: Number(0.001),
        initval: simSettn.eVstop,
        decimals: 3,
        boostat: 10,
        maxboostedstep: 0.005,
        postfix: 'eV',
        mousewheel: true
      });

      $("#eVstop_touch").on('touchspin.on.stopspin', function (e) {
          //console.log('eVstop_touch: ', $("#eVstop_touch").val());
          var tmp1 = Number($("#eVstop_touch").val());
          simSettn.eVstop = tmp1.toFixed(3);
          $('#eVStop').val(simSettn.eVstop);
          //prep. max value for eVstart_touch i.e. set 0.1eV minimum horiz. scale span:
          tmp1 = tmp1 - 0.1;
          $("#eVstart_touch").trigger("touchspin.updatesettings", {max: tmp1});
      });

      /*$("#eVStart").spinner({
        max: simSettn.eVstop-0.01,
        min: 0,
        step: 0.001,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value)+0.01;
          tmp1 = tmp1.toFixed(3);
          $("#eVStop").spinner('option','min',tmp1);
        }
      }).val(simSettn.eVstart);

      $("#eVStop").spinner({
        max: 4.0,
        min: simSettn.eVstart+0.1,
        step: 0.001,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value)-0.01;
          tmp1=tmp1.toFixed(3);
          $("#eVStart").spinner('option','max',tmp1);
        }
      }).val(simSettn.eVstop);*/

      var periodi; //for mousedown
      /************Boltzmann distr Et *************************************/
      $("#eV_Et").spinner({
        max: 4.0,
        min: 0,
        step: 0.001,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp = ui.value.toFixed(3);
          simSettn.eTr = tmp;
          makeJdos();       //density of states changes with Etr
          makeBoltz();      //Boltzmann distribution changes with Etr
          makeSommer();     //exciton enhanchement also
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          tmp1 = tmp1.toFixed(3);
          simSettn.eTr=tmp1;
          makeJdos();       //density of states
          makeBoltz();      //creates Boltzmann distribution
          makeSommer();     //exciton enhanchements
          calcInhom();
         }
      }).val(simSettn.eTr) //hide spinner up & down buttons:
      .parent().children('.ui-spinner-button').css('display','none');

      $("#Et_down").mousedown(function(){
        decrease_Et();
        periodi = setInterval(decrease_Et, 100);
      }).mouseup(function(){
        clearInterval(periodi);
      }).mouseout(function(){
        clearInterval(periodi);
      });

      function decrease_Et() {
        $("#eV_Et").spinner( "stepDown", 1 );
      }

      $("#Et_up").mousedown(function () {
        increase_Et();
        periodi = setInterval(increase_Et, 100);
      }).mouseup(function () {
        clearInterval(periodi);
      }).mouseout(function () {
        clearInterval(periodi);
      });

      function increase_Et() {
        $("#eV_Et").spinner("stepUp", 1);
      }
      /**********Boltzmann distr Et *************************************/

      /**********Boltzman distr T ***************************************/
      $("#tempK").spinner({
        max: 600,
        min: 0,
        step: 1,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp = ui.value.toFixed(0);
          simSettn.kelvin = tmp;
          makeBoltz();      //Boltzmann distribution changes with Temp [K]
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          tmp1 = tmp1.toFixed(3);
          simSettn.kelvin = tmp1;
          makeBoltz();      //Boltzmann distribution changes with T
          calcInhom();
        }
      }).val(simSettn.kelvin) // hide spinner up and down buttons
        .parent().children('.ui-spinner-button').css('display', 'none');

      $("#T_down").mousedown(function () {
        decrease_Temp();
        periodi = setInterval(decrease_Temp, 100);
      }).mouseup(function () {
        clearInterval(periodi);
      }).mouseout(function () {
        clearInterval(periodi);
      });

      function decrease_Temp() {
        $("#tempK").spinner("stepDown", 1);
      }

      $("#T_up").mousedown(function () {
        increase_Temp();
        periodi = setInterval(increase_Temp, 100);
      }).mouseup(function () {
        clearInterval(periodi);
      }).mouseout(function () {
        clearInterval(periodi);
      });

      function increase_Temp() {
        $("#tempK").spinner("stepUp", 1);
      }
      /**********Boltzman distr T ***************************************/

      $("#eV_Bind").spinner({
        max: 20,
        min: 0,
        step: 0.01,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp = ui.value.toFixed(3);
          simSettn.exEb = tmp;
          makeSommer();     //exciton enhanchements
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          tmp1 = tmp1.toFixed(3);
          simSettn.exEb = tmp1;
          makeSommer();     //exciton enhanchements
          calcInhom();
        }
      }).val(simSettn.exEb);

      $("#eV_0").spinner({
        //Exciton enhancement shape parameter for qw TM-polarization only
        max: 50,
        min: 0.01,
        step: 0.01,
        spin: function (event, ui) {
          //this.value; antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp = ui.value.toFixed(3);
          simSettn.ex0 = tmp;
          makeSommer();     //exciton enhanchements
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          tmp1 = tmp1.toFixed(3);
          simSettn.ex0 = tmp1;
          makeSommer();     //exciton enhanchements
          calcInhom();
        }
      }).val(simSettn.ex0);

      $("#eveu, #evSeu").spinner({
        //Urbach parameter spinner for both Urbach distributions
        max: 50,
        min: 0,
        step: 0.1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp = ui.value.toFixed(3);
          simSettn.eU = tmp;
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          tmp1 = tmp1.toFixed(3);
          simSettn.eU = tmp1;
          calcInhom();
        }
      }).val(simSettn.eU);

      $("#gauSig").spinner({
        //Gaussian broadening parameter
        max: 100,
        min: 1,
        step: 0.1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
          simSettn.GauSig = tmp1;
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          simSettn.GauSig = tmp1;
          calcInhom();
        }
      }).val(simSettn.GauSig);

      $("#sechN").spinner({
        //exponent parameter for Sech^n(t/(n*tau)) relaxation
        max: 10,
        min: 0.01,
        step: 0.01,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
          simSettn.SechN = tmp1;
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          simSettn.SechN = tmp1;
          calcInhom();
        }
      }).val(simSettn.SechN);

      $("#sechTau").spinner({
        //Relaxation time for Sech^n(t/(n*tau))
        max: 1000,
        min: 10,
        step: 1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
          simSettn.SechTau = tmp1;
          calcInhom();
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          simSettn.SechTau = tmp1;
          calcInhom();
        }
      }).val(simSettn.SechTau);

      $("#tauR").spinner({
        //reduced tau [fs] for Lorentz distribution
        max: 2000,
        min: 1,
        step: 1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
            simSettn.LorTau=tmp1;
            selBroadFun(Lorentz, 'Lorentz');
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
            simSettn.LorTau=tmp1;
            selBroadFun(Lorentz, 'Lorentz');
        }
      }).val(simSettn.LorTau);

      $("#tauBe").spinner({
        //tau for electron (or hole) relaxation in dual Lorentz distribution
        //plotted to homogeneous graph (second graph)
        max: 500,
        min: 1,
        step: 1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
          simSettn.DlTau1 = tmp1;
          selBroadFun(Dlorentz, 'Dlorentz');
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          simSettn.DlTau1 = tmp1;
          selBroadFun(Dlorentz, 'Dlorentz');
        }
      }).val(simSettn.DlTau1);

      $("#tauBh").spinner({
        //tau for hole (or electron) relaxation in dual Lorentz distribution
        //plotted into homogeneous graph (secong graph)
        max: 500,
        min: 1,
        step: 1,
        spin: function (event, ui) {
          //this.value antaa olleen arvon
          //ui.value antaa tulevan uuden arvon
          var tmp1 = Number(ui.value);
          simSettn.DlTau2 = tmp1;
          selBroadFun(Dlorentz, 'Dlorentz');
        },
        change: function (event, ui) {
          var tmp1 = Number(this.value);
          simSettn.DlTau2 = tmp1;
          selBroadFun(Dlorentz, 'Dlorentz');
        }
      }).val(simSettn.DlTau2);

      function selBroadFun(fun, funName){
        //fun:
        if ($("#pltHomConv").is(':checked')) {
          var kernel = makeFftKernel(fun);//use Lorentzian function in kernel
          var signal = padArray(inhomSpectr.plotArr);
          homSpectr.plotArr = unPad(fftConvo(signal, kernel));
        } else {
          broadFuns(funName);
        }
        hombr();
      }

      setJdosRadio();
      setQwRadio();

      $('input[type=radio][name=jdos]').change(function () {
          //console.log('jdos changed');
        if (this.value == 'bulk') {
          simSettn.jdostype='bulk';
          $("#qwendetls").css('display','none');
        } else if (this.value == 'qw') {
          simSettn.jdostype='qw';
          $("#qwendetls").css('display','block');
        }
          setJdosRadio();
          makeJdos();       //density of states
          makeSommer();
          calcInhom();
      });

      $('input[type=radio][name=dirBut]').change(function () {
        //viewing direction: Parallel or perpendicular to quantum well
        if (this.value == 'parallel') {
          $('#enhTE').attr('disabled',false);
          $('#enhTM').attr('disabled',false);
          simSettn.viewDir='parallel';
        } else if (this.value == 'perpend') {
          $('#enhTE').prop('checked',true);
          $('#enhTM').prop('checked',false);
          $('#enhTE').attr('disabled',true);
          $('#enhTM').attr('disabled',true);
          simSettn.viewDir='perpend';
        }
        makeSommer();
        calcInhom();
      });

      $('input[type=radio][name=enhBut]').change(function () {
        //Polarization selector:TE or TM
        if (this.value == 'TE') {
          simSettn.polarizat = 'TE';
          $('#eV_0').css('display','none');
          $('#lbl_eV0').css('display','none');
        }
        else if (this.value == 'TM') {
          simSettn.polarizat = 'TM';
          $('#eV_0').css('display', 'inline');
          $('#lbl_eV0').css('display', 'inline');
        }
        makeSommer();
        calcInhom();
      });

      /**
       * Function for graphing inhomog broadening
       * @function
       */
      function inhombr() {
        var opts = plot.getOptions(); // get a reference to the options
        if (inhomSpectr.plotArr.length<inhomSpectr.numPoints) {
          alert('no data for plotting!');
          return; //exit plotting if no data
        }
        if (graphSettn.inhomLinlog=='log') {
          opts.yaxes[0].axisLabel='Log10  Intensity';
        }else{
          opts.yaxes[0].axisLabel='Rel. Intensity';
        }
        var newData = [
          {data:LinOrLogs(graphSettn.inhomLinlog,inhomSpectr.plotArr,plot),
              color: "#4d94ff", xaxis: 1, yaxis: 1, label: graphSettn.inhomLegend},
          {data:LinOrLogExp(inhomSpectr.experArr,graphSettn.inhomLinlog),
              color: "#ffb380", xaxis: 1, yaxis: 1, label: 'Measured'}
        ];
        plot.setData(newData);
        plot.setupGrid();
        plot.draw();
        var graphTitle1 = (simSettn.jdostype == 'qw') ? 'using qw-jdos' : 'using bulk-jdos';
        var canvas = plot.getCanvas();
        var context = canvas.getContext('2d');
        context.font = "12pt sans-serif";
        context.lineWidth = 2;
        context.strokeStyle = "#4d94ff"; //"rgba(35, 70, 237, .8)";
        context.strokeText(graphTitle1, 20, 15);
        context.strokeStyle ="#ffb380"; //"rgba(35, 70, 237, .8)";
        var widthi=canvas.scrollWidth;
        widthi=Math.ceil(widthi/2);
        context.strokeText(graphSettn.inhomFileN, widthi, 15);
        hombr();
        //var imgs = canvas.toDataURL("image/png");
        //$("#huuhaa").html('<img src="' + imgs + '"/>');
      }

      /**
       * Function for graphing of homog broadening
       * @function
       */
      function hombr() {
        var opts = plot2.getOptions(); // get a reference to the options
        var canvas = plot2.getCanvas();
        var context = canvas.getContext('2d');
        context.font = "12pt sans-serif";
        context.lineWidth = 2;
        var homLege='';
        if (graphSettn.homLinlog == 'log') {
          opts.yaxes[0].axisLabel = 'Log10  Intensity';
        } else {
          opts.yaxes[0].axisLabel = 'Rel. Intensity';
        }
        if ($("#pltNormalize").is(':checked')) {
          arrNormalize(homSpectr.plotArr);
        }
        if ($("#pltHomConv").is(':checked')) {
          homLege=graphSettn.inhomLegend+"*Lh";
        }else{//ei homog leviämisen laskemista vain funktio:
          homLege='';
          if ($('#pltLorentz').prop('checked')) {
            homLege="Lorentz";
          }
          if ($('#pltDlorentz').prop('checked')) {
            homLege = "Lorentz1 x Lorentz2";
          }
        }
        var newData=[];
        if (homSpectr.plotArr.length == homSpectr.numPoints && homSpectr.experArr.length>1) {
          //console.log('pitäis olla kolme käyrää experimentti mukana');
          newData = [
            {data: LinOrLogs(graphSettn.homLinlog, inhomSpectr.plotArr, plot2),
                color: "#4d94ff", xaxis: 1, yaxis: 1, label: graphSettn.inhomLegend},
            {data: LinOrLogs(graphSettn.homLinlog, homSpectr.plotArr, plot2),
                color: "#00cc00", xaxis: 1, yaxis: 1, label: homLege},
            {data: LinOrLogExp(homSpectr.experArr, graphSettn.homLinlog),
                color: "#ff6666", xaxis: 1, yaxis: 1, label: 'Measured'}
          ];
          plot2.setData(newData);
          plot2.setupGrid();
          plot2.draw();
          context.strokeStyle = "#4d94ff";
          context.strokeText('Inhom.Sim.', 20, 15);
          context.strokeStyle = "#00cc00"; //"rgba(35, 70, 237, .8)";
          context.strokeText('Homog.Sim', 120, 15);
          context.strokeStyle = "#ff6666"; //"rgba(35, 70, 237, .8)";
          var widthi = canvas.scrollWidth;
          widthi = Math.ceil(widthi / 2);
          context.strokeText(graphSettn.homFileN, widthi, 15);
          console.log('homFileN: ',graphSettn.homFileN);
        }else if (homSpectr.plotArr.length == homSpectr.numPoints && homSpectr.experArr.length<1){
          //console.log('pitäis olla kaksi käyrää ei experimenttiä');
          newData = [
            {data: LinOrLogs(graphSettn.homLinlog,inhomSpectr.plotArr,plot2),
                color: "#4d94ff", xaxis: 1, yaxis: 1, label: graphSettn.inhomLegend},
            {data: LinOrLogs(graphSettn.homLinlog,homSpectr.plotArr,plot2),
                color: "#00cc00", xaxis: 1, yaxis: 1, label: homLege}
          ];
          plot2.setData(newData);
          plot2.setupGrid();
          plot2.draw();
          context.strokeStyle = "#4d94ff";
          context.strokeText('Inhom.Sim.', 20, 15);
          context.strokeStyle = "#00cc00"; //"rgba(35, 70, 237, .8)";
          context.strokeText('Homog.Sim', 120, 15);
        }else if (homSpectr.plotArr.length < homSpectr.numPoints && homSpectr.experArr.length>1){
          //console.log('pitäis olla kaksi käyrää, toisena experimentti');
          newData = [
            {data: LinOrLogs(graphSettn.homLinlog, inhomSpectr.plotArr, plot2),
                color: "#4d94ff", xaxis: 1, yaxis: 1, label: graphSettn.inhomLegend},
            {data: LinOrLogExp(homSpectr.experArr, graphSettn.homLinlog),
                color: "#ff6666", xaxis: 1, yaxis: 1, label: 'Measured'}
          ];
          plot2.setData(newData);
          plot2.setupGrid();
          plot2.draw();
          context.strokeStyle = "#4d94ff";
          context.strokeText('Inhom.Sim.', 20, 15);
          context.strokeStyle = "#ff6666"; //"rgba(35, 70, 237, .8)";
          var widthi = canvas.scrollWidth;
          widthi = Math.ceil(widthi / 2);
          context.strokeText(graphSettn.homFileN, widthi, 15);
        }else {
          //console.log('pitäis olla yksi käyrä: inhom simul');
          newData = [
            {data: LinOrLogs(graphSettn.homLinlog, inhomSpectr.plotArr, plot2),
                color: "#4d94ff", xaxis: 1,yaxis: 1,label: graphSettn.inhomLegend}
          ];
          plot2.setData(newData);
          plot2.setupGrid();
          plot2.draw();
          context.strokeStyle = "#4d94ff";
          context.strokeText('Inhom.Sim.', 20, 15);
        }
        //plot2.setData(newData);
        //plot2.setupGrid();
        //plot2.draw();
      }

      function makespArr(){
        var Start = parseFloat(simSettn.eVstart);//does not work without parseFloats
        var Stop = parseFloat(simSettn.eVstop);
        var n = parseInt(inhomSpectr.numPoints);
        var Del = (Stop - Start) / (n - 1);
        var helppi;
        inhomSpectr.eVarr=[];
        for (var i = 0; i < n; i++) {
          helppi = (Start + i * Del).toFixed(7);
          inhomSpectr.eVarr.push(helppi);
        }
      }

      function makeSommer(){
        //does not work without parseFloats
        var n = parseInt(inhomSpectr.numPoints);
        var Etr=parseFloat(simSettn.eTr);
        var Eb=parseFloat(simSettn.exEb);
        var eVs;
        inhomSpectr.exenArr=[];
        for (var i = 0; i < n; i++) {
          eVs = parseFloat(inhomSpectr.eVarr[i]);
          inhomSpectr.exenArr.push(Sommerf(eVs,Etr,Eb));
        }
      }

      function Sommerf(E,Etr,Eb) {
        var Pi_alfa;
        var Se=0;
        if (simSettn.jdostype == 'bulk'){
          if (E > Etr){
            Pi_alfa = Math.PI * Math.sqrt(Eb / 1000 / (E - Etr));
            Se = 2 * Pi_alfa * Math.exp(Pi_alfa) / (Math.exp(Pi_alfa) -
                    Math.exp(-Pi_alfa));
          }
          //return Se.toFixed(7);
        } else if (simSettn.jdostype == 'qw'){//jdos on qw
          if (simSettn.polarizat == 'TE'){
            if (E > Etr){
              Pi_alfa = Math.PI * Math.sqrt(Eb / 1000 / (E - Etr));
              Se = 2 * Math.exp(Pi_alfa) / (Math.exp(Pi_alfa) +
                      Math.exp(-Pi_alfa));
            }
            //return Se.toFixed(7);
          } else{
            //on TM polarisaatio:
            if (E > Etr){
              // use bias: simSettn.ex0 to prevent infinity at Etr
              Pi_alfa = Math.PI * Math.sqrt(Eb / 1000 / (E - Etr+simSettn.ex0/1000));
              Se = 2 * Math.exp(Pi_alfa) / (Math.exp(Pi_alfa) + Math.exp(-Pi_alfa));
              Se *=(1 + 4 * Eb/(E - Etr+simSettn.ex0/1000)/1000);
            }
            //return Se.toFixed(7);
          }
        }
        return Se.toFixed(7);
      }

      function makeBoltz(){
        var Etr = parseFloat(simSettn.eTr);
        var Temp = parseFloat(simSettn.kelvin);
        var n=parseInt(inhomSpectr.numPoints);
        var eVs;
        var m=0;
        inhomSpectr.fcvArr=[];
        for (var i = 0; i < n; i++) {
          eVs=parseFloat(inhomSpectr.eVarr[i]);
          if (Temp>0){//LED simulation:
            inhomSpectr.fcvArr.push(Boltzman(eVs,Etr,Temp));
          }else{// line emitter simulation:
            if (eVs<Etr || m>0){//no emission
              inhomSpectr.fcvArr.push(1E-30);
            }else {//emission only at one point, at or next to Etr
              inhomSpectr.fcvArr.push(1.0);
              m=1;
            }
          }
        }
      }

      function Boltzman(E, Etr, T) {
        var arvo = 0.0;
        if ((E - Etr) >= 0) {
          arvo = Math.exp(-eCha * (E - Etr) / (kBoltz * T));
        }
        return arvo;
      }

      function makeJdos() {
        inhomSpectr.jdosArr = [];
        var eVs;
        var num = parseInt(inhomSpectr.numPoints);
        var Etr = parseFloat(simSettn.eTr);
        var type = simSettn.jdostype;
        for (var i = 0; i < num; i++) {
          eVs = parseFloat(inhomSpectr.eVarr[i]);
          inhomSpectr.jdosArr.push(Jdos(Etr, eVs, type));
        }
      }

      /* functions for fft convolution
      *padArray pads values to array end making it equal in length with fft kernel
      */
      function padArray(toPad){
        var padded=[];
        var toInsert;
        for (var i=0;i<fftN;i++){
          if (i<toPad.length) {
            toInsert=parseFloat(toPad[i]);
          }else{
            if (i<(fftN+toPad.length)/2){
              //pads empty cells half with previous value and half with zero
              //this eliminates artifacts at both spectrum ends
              toInsert=parseFloat(toPad[toPad.length-1]);
              //without this padding spectrum end bends down
            }else{
              toInsert=0;
              //without this padding spectrum beginning bends up
            }
          }
          padded.push(toInsert);
        }
        return padded;
      }

      /* Function for fft convolution
       *function unPad removes padded values from the convolved array making it equal in length
       * with original array before convolution
       */
      function unPad(toUnpad){
        //console.log('unPadding');
        var unPadded = toUnpad.slice(0,inhomSpectr.numPoints);
        return unPadded;
      }

      /* Function for fft convolution
       * function makeFftKernel produces convolution kernel for FFT convolution
       */
      function makeFftKernel(toKern){
        //toKern is zero centered broadening (filter) function with Energy as parameter
        //toKern: Urbach, symUrbach, Lorentz, Gaussian, DLorentz
        // Sech: funktiolle tätä funktiota ei käytetä. Kerneli tuotetaan FFT:llä
        var kerneli=new Array(fftN);
        var Del=(parseFloat(simSettn.eVstop)-parseFloat(simSettn.eVstart))/
          (parseInt(inhomSpectr.numPoints)-1);
        var sum=0;
        for (var i=0;i<fftN;i++){
          if (i<fftN/2){
            kerneli[i]=toKern(-i*Del);
          }else{
            kerneli[i]=toKern(-(i-fftN)*Del);
          }
            sum+=kerneli[i];
        }
        for (var i=0;i<fftN;i++){
          kerneli[i]/=sum;
        }
        return kerneli;
      }

      function fftConvo(signal,kernel){
        var convoRes=new Array(fftN);
        var kernelSum=0;
        var i=0;
        for (i=0;i<kernel.length;i++){
          //obtain normalization parameter:
          kernelSum+=kernel[i];
        }
        //apply FFT-script:
        convolveReal(signal, kernel, convoRes);
        for (i= 0;i<fftN;i++){//normalize result:
          convoRes[i]/=kernelSum;
          if (convoRes[i]<=0) convoRes[i]=1e-100;
        }
        return convoRes;
      }

      function Jdos(Etr,E,type){
        var arvo=0;
        if (E >= Etr) {
          if (type=='bulk'){
            arvo = Math.sqrt(E - Etr); //bulk materials
          }else{
            arvo=1;  //Heaviside step function for quantum wells
          }
        }
        return arvo.toFixed(7);
      }

      function makeLih() {
        //produces inhomog spectrum  at Ef
        //used only for function shape plotting
        var Ef = parseFloat(simSettn.eTr);
        var n = parseInt(inhomSpectr.numPoints);
        var eVs;
        inhomSpectr.Lih=[];
        for (var i = 0; i < n; i++) {
          eVs=parseFloat(inhomSpectr.eVarr[i]);
          if ($('#pltUrbach').prop('checked')){
            inhomSpectr.Lih.push(Urbach(Ef-eVs));
          } else if ($('#pltsUrbach').prop('checked')) {
            inhomSpectr.Lih.push(symUrbach(Ef-eVs));
          } else if ($('#pltGaussian').prop('checked')){
            inhomSpectr.Lih.push(Gaussian(Ef-eVs));
          }
        }
        if ($('#pltSech').prop('checked')) {
          var sechBroad=sechFun();// palauttaa kaksi vektoria reali ja imagi fourier muunnoksesta
          inhomSpectr.Lih=sechUnpad(sechBroad);
        }
      }

      function broadFuns(funk) {
        //plots a function with max value at Etr
        var Etr = parseFloat(simSettn.eTr);
        var Estart=parseFloat(simSettn.eVstart);
        var Estop=parseFloat(simSettn.eVstop);
        var n = parseInt(inhomSpectr.numPoints);
        var delE=(Estop-Estart)/(n-1);
        var helppi=0;
        var E;
        var max=-1;
        var hjelppi = [];
        for (var i= 0;i<n;i++) {
          E = Etr - (Estart + i * delE);//maximum will be at Etr
          switch (funk) {
            case 'Lorentz':
              helppi=Lorentz(E);
              break;
            case 'Dlorentz':
              helppi = Dlorentz(E);
              break;
          }
          max = (max > helppi) ? max : helppi; //get the maximum value
          hjelppi.push(helppi);
        }
        if (!max>0) max=1;
        homSpectr.plotArr=[];
        for (var i = 0; i < n; i++) {
          homSpectr.plotArr.push(hjelppi[i] / max); //Normalizes to unity peak
        }
      }

      function LinOrLog(graphed){
        var arr=[];
        var max=0;
        for (var i=0;i<inhomSpectr.numPoints;i++){
          var tempi=[];
          tempi.push(parseFloat(inhomSpectr.eVarr[i]));
          tempi.push(parseFloat(graphed[i]));
          arr.push(tempi);
          max=(max<tempi[1])? tempi[1]:max;
        }
        max=Math.ceil(Math.log10(max)); //autoscale log axis max
        var min=max-5;                  //autoscale log axis min
        if (graphSettn.inhomLinlog == 'log') {
          for (var i = 0; i < inhomSpectr.numPoints; i++) {
            arr[i][1] = (arr[i][1]>1E-6)? Math.log10(arr[i][1]):-6;
          }
          plot.getAxes().yaxis.options.min = min; //scale log axis min
          plot.getAxes().yaxis.options.max = max;  //scale log axis max
        }else{
          plot.getAxes().yaxis.options.min = null; //autoscale
          plot.getAxes().yaxis.options.max = null; //autoscale
        }
        return arr;
      }

      function LinOrLogs(linOlog,graphed,kuva) {
        //LinOrLogs:  joko lin tai log
        //graphed:    on piirrettävän käyrän vektori
        //kuva:       on joko plot (inhomog) tai plot2 (homog)
        var arr = [];
        var max = 0;
        var nPoints=inhomSpectr.numPoints;
        for (var i = 0; i < nPoints; i++) {
          var tempi = [];
          tempi.push(parseFloat(inhomSpectr.eVarr[i]));
          tempi.push(parseFloat(graphed[i]));
          arr.push(tempi);
          max = (max < tempi[1]) ? tempi[1] : max;
        }
        max = Math.ceil(Math.log10(max));   //autoscale log axis max
        var min = max - 5;                  //autoscale log axis min
        if (linOlog == 'log') {
          for (var i = 0; i < nPoints; i++) {
            arr[i][1] = (arr[i][1] > 1E-6) ? Math.log10(arr[i][1]) : -6;
          }
          kuva.getAxes().yaxis.options.min = min; //scale log axis min
          kuva.getAxes().yaxis.options.max = max;  //scale log axis max
        } else {
          kuva.getAxes().yaxis.options.min = 0; //autoscale
          kuva.getAxes().yaxis.options.max = null; //autoscale
        }
        return arr;
      }

      function LinOrLogExp(measArr,lineLoga) {
        console.log('linorlog length: ',measArr.length);
        var arr=[];
        for (var i = 1; i < measArr.length; i++) {
          var tempi = [];
          tempi.push(measArr[i][0]);
          tempi.push(measArr[i][1]);
          arr.push(tempi);
        }
        if (lineLoga == 'log') {
          for (var i = 0; i < measArr.length-1; i++) {
            arr[i][1] = (arr[i][1] > 1E-6) ? Math.log10(arr[i][1]) : -6;
          }
        }
        return arr;
      }

      function Urbach(E) {
        var helppi = 0;
        var Eu = parseFloat(simSettn.eU);
        if (E >= 0) {
          helppi = Math.exp(-E * 1000 / Eu)*1000/Eu; //integrates to unity
        }
        return helppi;
      }

      function symUrbach(E) {
        var Eu = parseFloat(simSettn.eU);
        var helppi = Math.exp(-Math.abs(E) * 1000 / Eu)*500 / Eu; //integrates to unity
        return helppi;
      }

      function Lorentz(E){
        var tau = simSettn.LorTau * 1.0E-15; //to femtoseconds
        var helppi = eCha * hBar * tau / Math.PI / (hBar * hBar + tau * tau
          * E * E * eCha * eCha);
        return helppi;
      }

      function Dlorentz(E) {
        var tau1 = simSettn.DlTau1 * 1.0E-15; //in seconds
        var tau2 = simSettn.DlTau2 * 1.0E-15;
        var helppi = eCha * (tau1 + tau2) / Math.PI / hBar / (1 + tau1 * tau1 * E * E / hBar
           / hBar * eCha * eCha) / (1 + tau2 * tau2 * E * E / hBar / hBar * eCha * eCha);
        return helppi;
      }

      function Gaussian(E) {
        var sigma = simSettn.GauSig/1000; //meV to eV
        var helppi = (Math.exp(-E * E / 2 / sigma / sigma)) / sigma /
          Math.sqrt(2 * Math.PI);
        return helppi;
      }

      function sechFun() {
        var schN =simSettn.SechN;
        var schTau =simSettn.SechTau*1E-15; //Convert femtoseconds into seconds
        var E0=simSettn.eVstart;
        var E999=simSettn.eVstop;
        //fft time delta after padding:
        var eDelta=fftN*(E999-E0)/(inhomSpectr.numPoints-1)*eCha;
        // missä huomioitu paddingin tuoma lisäys spektrin pituuteen
        // h/deltaE=1/deltaf; Energy range determines frequency resolution,
        var tDelta=hPlanck/eDelta;
        //antaa saman kuin excelin sech-fun.xslx sheet
        // number of samples determines spectral (frequency) range
        tDelta=tDelta/schN/schTau; //for variable in: p(t) = sech^n(t/n/tau)
        // tehdään relaksaation aikafunktio p(t) prop. sech^n(t/n/tau)
        // mistä leviämisspectri sitten fft:llä
        var reali=[]; //fft:n reaaliosa
        var imagi=[]; //fft:n imaginääriosa
        var helppi;
        for (var i=0;i<(fftN);i++){
          var temp=(i-fftN/2)*tDelta;
          //raja jottei tule div. by zeroa:
          if(temp<Math.log(1E300) && temp>Math.log(1E-300)){
            helppi=Math.pow(2/(Math.exp(temp)+Math.exp(-temp)),schN); //sech(x)=1/cosh(x)
          }else {
            helppi=1E-300;
          }
          reali.push(helppi);
          imagi.push(0);
        }
        //tehdään fourier muunnos fft:llä
        transform(reali, imagi); //tässä on fft:n määräämä vektorien pituus (fftN)
        return [reali,imagi];
      }

      function sechUnpad(sechBroad){
        //tarvitaan redusoimaan fft:n tuottamat vektorit inhomSpectr.numPoints pituiseksi
        // vain leviämisspektrin piirtorutiinissa
        var Ef = parseFloat(simSettn.eTr);
        var n = parseInt(inhomSpectr.numPoints);
        var absVal=[];
        var TEMp;
        var positio = (Ef - simSettn.eVstart) / (simSettn.eVstop - simSettn.eVstart) * n;
        positio = Math.round(positio); //indexi johon sech spectrin huippu tulee
        for (var i = 0; i < n; i++) {
          var x = positio - i;
          if (x > 0) {
            TEMp=sechBroad[0][fftN - 1 - x] * sechBroad[0][fftN - 1 - x] + sechBroad[1][fftN - 1 - x] * sechBroad[1][fftN - 1 - x];
          } else {
            TEMp = sechBroad[0][-x] * sechBroad[0][-x] + sechBroad[1][-x] * sechBroad[1][-x];
          }
          absVal.push(Math.sqrt(TEMp));
        }
        return absVal;
      }

      // inhomogeneous plot Create a div for each axis
      $.each(plot.getAxes(), function (i, axis) {
        if (!axis.show)
          return;
        var box = axis.box;
        $("<div class='axisTarget' style='position:absolute; left:" + box.left + "px; top:"
          + box.top +"px; width:" + box.width + "px; height:" + box.height + "px'></div>")
          .data("axis.direction", axis.direction)
          .data("axis.n", axis.n)
          .css({backgroundColor: "#f00", opacity: 0, cursor: "pointer"})
          .appendTo(plot.getPlaceholder())
          .hover(
            function () {//handler for hover in:
              $(this).css({opacity: 0.10});
              //-$("#clicked").text("You hovered 0.1 " + axis.direction + axis.n + "axis!");
              if (axis.direction=='y') {
                showTooltip(box.left+box.width, box.top+box.height/2, 'Click to toggle lin/log');
              }else{
                showTooltip(box.left+box.width/2, box.top-box.height, 'Click to edit range');
                }
            },
            function () {//handler for hover out:
              $(this).css({opacity: 0});
              //-$("#clicked").text("You hovered 0 " + axis.direction + axis.n + "axis!");
              $("#tooltip").remove();
            }
          )
          .click(function () {
            if  (axis.direction=='y') {
              graphSettn.inhomLinlog = (graphSettn.inhomLinlog == 'lin') ? 'log' : 'lin';
              inhombr();
            }else{
              //click on x-axis: displays spectral settings selector
              //$("#spRange").css('display','block');
              //$( "#settnDial" ).dialog( "open" );
              inhomSettns_dialog();
              }
              //$("#clicked").text("You clicked the " + axis.direction + axis.n + "axis!");
          });
      });

      // inhomogeneous plot Create a div for each axis
      $.each(plot2.getAxes(), function (i, axis) {
        if (!axis.show)
          return;
        var box = axis.box;
        $("<div class='axisTarget' style='position:absolute; left:" + box.left + "px; top:"
          + box.top + "px; width:" + box.width + "px; height:" + box.height + "px'></div>")
          .data("axis.direction", axis.direction)
          .data("axis.n", axis.n)
          .css({backgroundColor: "#f00", opacity: 0, cursor: "pointer"})
          .appendTo(plot2.getPlaceholder())
          .hover(
            function () {//handler for hover in:
              $(this).css({opacity: 0.10});
              //-$("#clicked").text("You hovered 0.1 " + axis.direction + axis.n + "axis!");
              if (axis.direction == 'y') {
                showTooltip2(box.left + box.width, box.top + box.height / 2, 'Click to toggle lin/log');
              } else {
                showTooltip2(box.left + box.width / 2, box.top - box.height, 'Click to edit range');
              }
            },
            function () {//handler for hover out:
              $(this).css({opacity: 0});
              //-$("#clicked").text("You hovered 0 " + axis.direction + axis.n + "axis!");
              $("#tooltip").remove();
            }
          )
          .click(function () {
            if (axis.direction == 'y') {
              graphSettn.homLinlog = (graphSettn.homLinlog == 'lin') ? 'log' : 'lin';
                hombr();
            } else {
              //clicked on x-axis: display spectral range editor
              //$("#spRange").css('display', 'block');
              //-$("#spWhat").css('display','block');
              //$("#settnDial").dialog("open");
              homogSettns_dialog();
              }
            //$("#clicked").text("You clicked the " + axis.direction + axis.n + "axis!");
          });
      });

      inhombr();

      $("#ph1_inhomog").mouseleave(function() {
        $("#tooltip").remove();
      });
      $("#ph2_homog").mouseleave(function () {
        $("#tooltip").remove();
      });

      $("#ph1_inhomog").bind("plothover", function (event, pos, item) {
        //$("#clicked").text("You hovered at: " + pos.x + ','+ pos.y+'event.target: '+event.target);
        showTooltip(40, 30, 'DblClick to edit graph');
        //-alert("You clicked at " + pos.x + ", " + pos.y);
        // axis coordinates for other axes, if present, are in pos.x2, pos.x3, ...
        // if you need global screen coordinates, they are pos.pageX, pos.pageY
        if (item) {
          var point='E: '+(pos.x).toFixed(4)+' val: '+ (pos.y).toFixed(4);
          showTooltip(40, 30, point);
          //highlight(item.series, item.datapoint);
          //$("#clicked").text("You hovered at: " + item.series + ',' +item.datapoint);
          //alert("You clicked a point!");
        }
      });

      $("#ph2_homog").bind("plothover", function (event, pos, item) {
        //$("#clicked").text("You hovered at: " + pos.x + ','+ pos.y+'event.target: '+event.target);
        showTooltip2(40, 30, 'DblClick to edit graph');
        //-alert("You clicked at " + pos.x + ", " + pos.y);
        // axis coordinates for other axes, if present, are in pos.x2, pos.x3, ...
        // if you need global screen coordinates, they are pos.pageX, pos.pageY
        if (item) {
          var point = 'E: ' + (pos.x).toFixed(4) + ' val: ' + (pos.y).toFixed(4);
          showTooltip2(100, 30, point);
          //highlight(item.series, item.datapoint);
          //$("#clicked").text("You hovered at: " + item.series + ',' +item.datapoint);
          //alert("You clicked a point!");
        }
      });

      function showTooltip(x, y, contents) {
        //console.log('showing tooltip: ',x,' ',y, ' ',contents);
        if ($("#tooltip").length > 0) {
          $("#tooltip").remove();
        }
        $('<div id="tooltip">' + contents + '</div>').css({
          position: 'absolute', display: 'none', top: y + 5, left: x + 5,
          border: '1px solid #fdd', padding: '2px', 'background-color': '#fee', opacity: 0.80
        }).appendTo("#ph1_inhomog").fadeIn(200);
      }

      function showTooltip2(x, y, contents) {
        //console.log('showing tooltip: ',x,' ',y, ' ',contents);
        if ($("#tooltip").length > 0) {
          $("#tooltip").remove();
        }
        $('<div id="tooltip">' + contents + '</div>').css({
          position: 'absolute', display: 'none', top: y + 5, left: x + 5,
          border: '1px solid #fdd', padding: '2px', 'background-color': '#fee', opacity: 0.80
        }).appendTo("#ph2_homog").fadeIn(200);
      }

      function setChkboxes(){
        $('#pltEpsilon').prop('checked', inhomSpectr.inPlot.eV);
        $('#pltJdos').prop('checked', inhomSpectr.inPlot.jdos);
        $('#pltSommerf').prop('checked', inhomSpectr.inPlot.Se);
        $('#pltFcv').prop('checked', inhomSpectr.inPlot.fcv);
        $('#pltUrbach').prop('checked', inhomSpectr.inPlot.Lurb);
        $('#pltsUrbach').prop('checked', inhomSpectr.inPlot.Lsurb);
        $('#pltGaussian').prop('checked', inhomSpectr.inPlot.Lgaus);
        $('#pltSech').prop('checked', inhomSpectr.inPlot.Lsech);
        //$('#pltLorentz').prop('checked', false);
        //$('#pltDlorentz').prop('checked', false);
        //calcInhom();
      }

      function setLegend(){
        graphSettn.inhomLegend = '';
        var dotti = '\u00B7'; //multiplication dot
        var regexi = /^\u00B7+/;
        if (inhomSpectr.inPlot.eV) graphSettn.inhomLegend = 'E';
        if (inhomSpectr.inPlot.jdos) graphSettn.inhomLegend += dotti + 'Jdos';
        if (inhomSpectr.inPlot.Se) graphSettn.inhomLegend += dotti + 'Se';
        if (inhomSpectr.inPlot.fcv) graphSettn.inhomLegend += dotti + 'Fcv';
        if ((inhomSpectr.inPlot.Lurb || inhomSpectr.inPlot.Lsurb) &&
          !inhomSpectr.inPlot.convo) graphSettn.inhomLegend='Lih';
        graphSettn.inhomLegend.trim();
        //remove leading multiplication dot(s):
        graphSettn.inhomLegend = graphSettn.inhomLegend.replace(regexi,'');
        if (inhomSpectr.inPlot.convo){
          graphSettn.inhomLegend = '(' + graphSettn.inhomLegend + ')*Lih';
        }
      }

      function multPlotted(arra){
        num=inhomSpectr.numPoints;
        if (inhomSpectr.plotArr.length<1){
          for (var i=0;i<num;i++) {
            inhomSpectr.plotArr.push(arra[i]);
          }
        }else{
          for (var j=0;j<num;j++) {
            inhomSpectr.plotArr[j]=arra[j]*inhomSpectr.plotArr[j];
          }
        }
      }

      function calcInhom(){
        inhomSpectr.plotArr=[];
        //valinnoista tehdään piirrettävä array:
        if (inhomSpectr.inPlot.eV){
          multPlotted(inhomSpectr.eVarr);
        }
        if (inhomSpectr.inPlot.jdos) {
          multPlotted(inhomSpectr.jdosArr);
        }
        if (inhomSpectr.inPlot.Se) {
          multPlotted(inhomSpectr.exenArr);
        }
        if (inhomSpectr.inPlot.fcv) {
          multPlotted(inhomSpectr.fcvArr);
        }//piirrettävä funktio saatiin valmiiksi konvoluutiota tai piirtoa varten
        //jos mitään ollut valittuna leviämisfunktion kanssa, piirretään vain leviämisfunktio:
        if (!inhomSpectr.inPlot.convo && (inhomSpectr.inPlot.Lurb || inhomSpectr.inPlot.Lsurb
          || inhomSpectr.inPlot.Lgaus || inhomSpectr.inPlot.Lsech)) {
          //siis ei konvoluutiota vain joku levenemisfunktioista piirtoon
          makeLih(); //laskee valitun levimisfunktion Etr kohtaan
          inhomSpectr.plotArr=[]; //tyhjennys
          console.log('Lih piirto');
          multPlotted(inhomSpectr.Lih); //täyttö vain leviämisfunktio
        }
        if (inhomSpectr.inPlot.convo) {
          //valittu leviämisfunktio ja 'plotting selectorista' itemi(t):
          //vuorossa konvoluution laskeminen:
          var kernel=[]; //nollataan konvoluutiokernel
          var signal=padArray(inhomSpectr.plotArr); //tehdään konvolutoitavasta fftN pituinen
          if (inhomSpectr.inPlot.Lsurb) {//symmetrinen Urbach
            kernel = makeFftKernel(symUrbach); //symUrbach konvoluution kerneliksi
          } else if (inhomSpectr.inPlot.Lurb) {//asymmetric urbach
            kernel = makeFftKernel(Urbach); //Urbach konvoluution kerneliksi
          } else if (inhomSpectr.inPlot.Lgaus){//gaussian broadening
            kernel = makeFftKernel(Gaussian); //gaussin funktio konvoluution kerneliksi
          } else if (inhomSpectr.inPlot.Lsech){//sech functio laskettu fft:llä,
            // eroava  kernelin laskenta:
            var ckernel=sechFun(); //saadaan 2 (fftN-pituista) vektoria: ckernel[0] and ckernel[1]
            for (var I=0;I<fftN;I++){
              //kompleksiluvun abs arvot kerneliin
              kernel.push(Math.sqrt(ckernel[0][I]*ckernel[0][I]+ckernel[1][I]*ckernel[1][I]));
            }
          }
          inhomSpectr.plotArr=unPad(fftConvo(signal,kernel));//konvoluutio ja unpadding
          /*if ((inhomSpectr.inPlot.Lsurb || inhomSpectr.inPlot.Lurb || inhomSpectr.inPlot.Lgaus || inhomSpectr.inPlot.Lsech ) && inhomSpectr.inPlot.eV && inhomSpectr.inPlot.Se
            && inhomSpectr.inPlot.fcv){
            arrNormalize(inhomSpectr.plotArr);
          }*/
        }
        if ($("#pltNormalize").is(':checked')) {
          arrNormalize(inhomSpectr.plotArr);
        }
        inhombr();
        if ($('#pltHomConv').prop('checked')) {
          calcHom();
          hombr();
        }
      }

      /*function normalizes convolution max value to 1
      *
      */
      function arrNormalize(arr){
        var n=arr.length;
        var max = 0;
        var i;
        for (i = 0; i < n; i++) {
          max = (arr[i] > max) ? max = arr[i] : max;
        }
        for (i = 0; i < n; i++) {
          arr[i] = arr[i] / max;
        }
      }

      $("#pltUrbach, #pltsUrbach, #pltGaussian, #pltSech").click(function(){
        //checkbox selections for inhomogeneous broadening
        if ($(this).attr('id') == 'pltUrbach' && $(this).prop('checked')==true) {
          $('#pltsUrbach, #pltGaussian, #pltSech').prop('checked', false);//uncheck other broadenings:
        }
        if ($(this).attr('id') == 'pltsUrbach' && $(this).prop('checked')==true) {
          $('#pltUrbach, #pltGaussian, #pltSech').prop('checked', false);//uncheck other broadenings:
        }
        if ($(this).attr('id') == 'pltGaussian' && $(this).prop('checked') == true) {
          $('#pltUrbach, #pltsUrbach, #pltSech').prop('checked', false);//uncheck other broadenings:
        }
        if ($(this).attr('id') == 'pltSech' && $(this).prop('checked') == true) {
          $('#pltUrbach, #pltGaussian, #pltsUrbach').prop('checked', false);//uncheck other broadenings:
        }
        setLegend();
        calcInhom();
      });

      $("#pltHomConv").click(function(){
        if ($(this).is(':checked')){
          homSpectr.inPlot.convo=true;
        }else{
          homSpectr.inPlot.convo=false;
        }
      });

      //response inhomog checkbox change events:
      $("#pltEpsilon, #pltJdos, #pltSommerf, #pltFcv, #pltUrbach, #pltsUrbach, #pltGaussian, #pltSech").change(function () {
        inhomSpectr.inPlot.eV = ($('#pltEpsilon').prop('checked'))? true : false;
        inhomSpectr.inPlot.jdos = ($('#pltJdos').prop('checked'))? true : false;
        inhomSpectr.inPlot.Se = ($('#pltSommerf').prop('checked')) ? true : false;
        inhomSpectr.inPlot.fcv = ($('#pltFcv').prop('checked')) ? true : false;
        inhomSpectr.inPlot.Lurb = ($('#pltUrbach').prop('checked')) ? true : false;
        inhomSpectr.inPlot.Lsurb = ($('#pltsUrbach').prop('checked')) ? true : false;
        inhomSpectr.inPlot.Lgaus = ($('#pltGaussian').prop('checked')) ? true : false;
        inhomSpectr.inPlot.Lsech = ($('#pltSech').prop('checked')) ? true : false;
        inhomSpectr.inPlot.convo = false;
        if ((inhomSpectr.inPlot.eV || inhomSpectr.inPlot.jdos || inhomSpectr.inPlot.Se
          || inhomSpectr.inPlot.fcv) && (inhomSpectr.inPlot.Lurb==true || inhomSpectr.inPlot.Lsurb==true
          || inhomSpectr.inPlot.Lgaus==true || inhomSpectr.inPlot.Lsech==true)) {
          inhomSpectr.inPlot.convo = true;
        }
        //console.log('klikattu: ',this.id,' checked: ',$(this).is(':checked'));
        //makeJdos();       //density of states
        setLegend();
        calcInhom();
      });

      //response to homog checkbox change events:
      $("#pltLorentz, #pltDlorentz").change(function () {
        //console.log($(this).attr('id'),' changed', $(this).prop('checked'));
        var poksi = $(this).is(':checked'); //tai: var poksi=$(this).prop('checked'));
        //First uncheck both checkboxes:
        $('#pltLorentz, #pltDlorentz').prop('checked', false);
        $(this).prop('checked', poksi); //sets only clicked chkbox back to chosen state:
        if (!$(this).is(':checked')) {//valinnat ovat pois päältä
          homSpectr.plotArr = [];
        } else {
          switch ($(this).attr('id')) {
            case 'pltLorentz':
              if ($("#pltHomConv").is(':checked')) {//convolution plot:
                var kernel = makeFftKernel(Lorentz);//use Lorentzian function in kernel
                var signal = padArray(inhomSpectr.plotArr);
                  homSpectr.plotArr = unPad(fftConvo(signal, kernel));
                } else {//only plot function
                  broadFuns('Lorentz');
                }
                break;
            case 'pltDlorentz':
              if ($("#pltHomConv").is(':checked')) {//calculate and plot convolution:
                var kernel = makeFftKernel(Dlorentz);//use DLorentzian function in kernel
                var signal = padArray(inhomSpectr.plotArr);
                homSpectr.plotArr = unPad(fftConvo(signal, kernel));
                //arrNormalize(homSpectr.plotArr);
              } else {
                broadFuns('Dlorentz');
              }
                break;
          }
        }
        hombr(); //piirtää käyrän
      });

      $("#pltHomConv").click(function () {
          homSpectr.inPlot.convo = ($(this).is(':checked'));
      });

      $("#pltHomConv").change(function () {
        if (!($("#pltDlorentz").is(':checked')) && !($("#pltLorentz").is(':checked'))) {
          homSpectr.plotArr = []; //kumpikaan leviämisfunktio ei ole valittuna
        } else {//jompikumpi levenemisistä on valittuna
          if (homSpectr.inPlot.convo==true) {//konvoluutio on valittuna
            if ($("#pltLorentz").is(':checked')) {
              var kernel = makeFftKernel(Lorentz);//use Lorentzian function in kernel
            } else {
              var kernel = makeFftKernel(Dlorentz);//use Dlorentzian function in kernel
            }
            var signal = padArray(inhomSpectr.plotArr);
            homSpectr.plotArr = unPad(fftConvo(signal, kernel));
          } else {//ei konvoluutiota vain toinen funktioista piirretään
            if ($('#pltLorentz').is(':checked')) {
              broadFuns('Lorentz');
            } else if ($('#pltDlorentz').is(':checked')){
              broadFuns('Dlorentz');
            }
          }
        }
        hombr();
      });

      $("#pltNormalize").change(function () {
        //calcHom();
        //hombr();
        if ($(this).is(':checked')) {
          arrNormalize(inhomSpectr.plotArr);
          inhombr();
        }else{
          calcInhom();
        }
      });

      function calcHom(){
        //check if any of the broadening functions is checked
        var broadSel = $('#pltLorentz').is(':checked');
        broadSel = broadSel || $('#pltDlorentz').is(':checked');
        if ($("#pltHomConv").is(':checked') && broadSel) {
          //convolution calculated and plotted
          if ($('#pltLorentz').is(':checked')) {
            //use Lorentzian function in kernel
            var kernel = makeFftKernel(Lorentz);
            var signal = padArray(inhomSpectr.plotArr);
          } else if ($('#pltDlorentz').is(':checked')) {
            //use Dlorentz in kernel
            var kernel = makeFftKernel(Dlorentz);
            var signal = padArray(inhomSpectr.plotArr);
          }
            homSpectr.plotArr = unPad(fftConvo(signal, kernel));
            //hombr();
        } else {
          //convolution not calculated only broadening function plotted
          if ($('#pltLorentz').is(':checked')) {
            broadFuns('Lorentz');
          } else if ($('#pltDlorentz').is(':checked')) {
            broadFuns('Dlorentz');
          }
        }
        hombr();
      }

      function makeExpArrs(){
        //treat experimental results for spectral range change;
        var m = inhomSpectr.experPlot.length; //data read from file
        var n = homSpectr.experPlot.length; //data read from file
        //console.log('inhomSpectr.experPlot.length: ',m);
        //console.log('homSpectr.experPlot.length: ',n);
        var k = inhomSpectr.numPoints - 1;
        //console.log('inhomSpectr.experArr.length: ',inhomSpectr.experArr.length," m: ",m);
        //console.log('homSpectr.experArr.length: ',homSpectr.experArr.length," n: ",n);
        inhomSpectr.experArr = [];
        homSpectr.experArr = [];
        for (var j = 0; j < m; j++) {
          var tmp1 = [];
          if (m > 0 && inhomSpectr.experPlot[j][0] > inhomSpectr.eVarr[0] && inhomSpectr.experPlot[j][0] < inhomSpectr.eVarr[k]) {
            tmp1.push(inhomSpectr.experPlot[j][0]);
            tmp1.push(inhomSpectr.experPlot[j][1]);
            inhomSpectr.experArr.push(tmp1);
          }
        }
        for (var i=0;i<n;i++){
          var tmp2 = [];
          if (n > 0 && homSpectr.experPlot[i][0] > inhomSpectr.eVarr[0] && homSpectr.experPlot[i][0] < inhomSpectr.eVarr[k]) {
            tmp2.push(homSpectr.experPlot[i][0]);
            tmp2.push(homSpectr.experPlot[i][1]);
            homSpectr.experArr.push(tmp2);
          }
        }
        //console.log('inhomSpectr.experArr.length: ',inhomSpectr.experArr.length);
        //console.log('homSpectr.experArr.length: ',homSpectr.experArr.length);
      }

      $("#rangeok, #evetok, #jdosok, #exenhaok, #urbachok, #sUrbachok, #whatok").click(function(){
        switch ($(this).attr('id')){
          case 'rangeok':
            //simSettn.eVstart=parseFloat($("#eVStart").spinner("value")).toFixed(3);
            //simSettn.eVstop=parseFloat($("#eVStop").spinner("value")).toFixed(3);

            //$("#eVStart").spinner("option", "value", simSettn.eVstart);
            //$("#eVStop").spinner("option", "value", simSettn.eVstop);
            //$("#eVstop_touch").trigger("touchspin.updatesettings", {max: simSettn.eVstop});
            makespArr();       //recreate spectral array
            makeExpArrs();     //recreate experimental array
            makeJdos();
            makeBoltz();       //recreate Boltzmann distribution
            makeSommer();
            calcInhom();
            calcHom();
            break;
            case 'evetok':
            //makeBoltz();//jdos, exiton and Boltzmann changes updated in spinner events
            calcInhom();
            calcHom();
            break;
          case 'jdosok':
            makeJdos(); //exiton changes updated in jdos radio button change event
            calcInhom();
            calcHom();
            break;
          case 'exenhaok':
            makeSommer();
            calcInhom();
            calcHom();
            break;
          case 'urbachok':
          case 'sUrbachok':
            calcInhom();
            calcHom();
            break;
          case 'whatok':
            break;
        }
        var parentti = $(this).parent();
        parentti.css('display', 'none');
        var onkojoku=0;
        $('fieldset','#settnDial').each(function(){
          var a=$(this).attr('style');
          onkojoku += (a.search('block')>-1)? 1:0;
        });
        //if all fieldsets are closed close also dialogform:
        $('#settnDial').dialog('close');
          if (onkojoku>0) {
            $('#settnDial').dialog('open');
            setJdosRadio();
            setQwRadio();
          }
      });

      $("#lorentzok").click(function(){
        $("#spLorentz").css('display','none');
      });

      $("#dlorentzok").click(function () {
        $("#spDlorentz").css('display', 'none');
      });

      $("#gaussianok").click(function () {
        $("#spGaussian").css('display', 'none');
      });

      $("#sechok").click(function () {
        $("#spSech").css('display', 'none');
      });

      $('#hrefEpsilon').click(function(){
        $("#spRange").css('display','block');
        $("#settnDial").dialog("close");
        $("#settnDial").dialog("open");
        setJdosRadio();
      });

      $('#hrefJdos').click(function () {
        $("#spJdos").css('display','block');
        $("#settnDial").dialog("close");
        $("#settnDial").dialog("open");
        setJdosRadio();
      });

      $('#hrefSommerf').click(function(){
        $("#exEnha").css('display','block');
        $("#settnDial").dialog("close");
        $("#settnDial").dialog("open");
        setJdosRadio();
        setQwRadio();
      });

      $('#hrefTransito').click(function () {
        //click on transition energy title
        $("#eg_et").css('display','block');
        $("#settnDial").dialog("close");
        $("#settnDial").dialog("open");
        setJdosRadio();
        setQwRadio();
      });

      $('#hrefUrbach').click(function() {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spUrbach").css('display', 'block');
        $("#settnDial").dialog("open");
      });

      $('#hrefsUrbach').click(function () {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spSurbach").css('display', 'block');
        $("#settnDial").dialog("open");
      });

      $('#hrefLorentz').click(function () {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spLorentz").css('display', 'block');
        $("#settnDial").dialog("open");
      });

      $('#hrefdLorentz').click(function () {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spDlorentz").css('display', 'block');
        $("#settnDial").dialog("open");
      });

      $('#hrefGaussian').click(function () {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spGaussian").css('display', 'block');
        $("#settnDial").dialog("open");
      });

      $('#hrefSech').click(function () {
        $("#spUrbach, #spLorentz, #spSurbach, #spDlorentz, #spGaussian, #spSech").css('display', 'none');
        $("#settnDial").dialog("close");
        $("#spSech").css('display', 'block');
        $("#settnDial").dialog("open");
      });


      /* Function for operations after local emission file selection has changed
      *  Handler for reading local emission data files
      */
      $("#emisLocFiles").on("change", function () {
        var selected_file = $('#emisLocFiles').get(0).files[0];
        //console.log('selected_file: ',selected_file);
        if (!selected_file) return;
        //var dialTitle=$("#mongoDialForm").dialog("option","title");
        var dialoogi= $('#settnDial').dialog('option','title');
        if (dialoogi == 'Inhomogeneous spectrum') {
          if ($('#radioMeas').is(':checked')) {
            // measured spectrum array read to the inhomog plot
            // with eV and intensity values , one pair per row
            // after async read data processed in 'gotInhomFile' callback
            graphSettn.inhomFileN= selected_file.name;
            ReadLocFle(selected_file, gotInhomFile);
          } else {
            // reads simulation parameters to inhomog plot
            // after async read data processed in 'gotInhomSim' callback
            // console.log('reads inhomog simul.pars');
            ReadLocFle(selected_file, gotInhomSim);
          }
        } else if (dialoogi == 'Homogeneous spectrum') {
          if ($('#radioMeas').is(':checked')) {
            // reads measured spectrum array to the homog plot
            // with eV and intensity values , one pair per row
            // after async read data processed in 'gotHomogFile' callback
            // console.log('reads homog measurement');
            graphSettn.homFileN=selected_file.name;
            ReadLocFle(selected_file, gotHomogFile);
          } else {
            //reads simuation parameters to the homog plot
            // after async read data processed in 'gotHomogSim' callback
            console.log('reads homog simul.pars');
            ReadLocFle(selected_file, gotInhomSim);
          }
        }
      });

      $("#footer").prepend("Flot graph" + $.plot.version + " &ndash; ");

      /**
       * Function for callback operation after reading local emission spectrum file
       * @function
       * @fileCont has the read text content
       */
      function gotInhomFile(fileCont) {
          //callback after successfully reading a local emission file
          try {
              inhomSpectr.experArr = splitToArr(fileCont);
              inhomSpectr.experPlot = splitToArr(fileCont);
              var descr = homSpectr.experPlot[0][2];
              descr = descr.replace(/"/g, "");
              $('#inhDescLbl').css('display', 'inline');
              $('#inhDesc').css('display', 'inline');
              $('#inhDesc').html(descr);
              inhombr();
          }
          catch(err) {
            alert('Error in selected inhomogeneous emission data');
          }
      }

      /**
       * Function for callback operation after reading local emission spectrum file
       * @function
       * @fileCont has the read text content
       */
      function gotHomogFile(fileCont) {
          //callback after successfully reading a local emission file
          try {
              homSpectr.experArr = splitToArr(fileCont);
              homSpectr.experPlot = splitToArr(fileCont);
              var descr = homSpectr.experPlot[0][2];
              descr = descr.replace(/"/g, "");
              $('#homDescLbl').css('display', 'inline');
              $('#homDesc').css('display', 'inline');
              $('#homDesc').html(descr);
              hombr();
          }
          catch(err){
              alert('Error in selected homogeneous emission data');
          }
      }


      function gotInhomSim(fileCont){
        //Header: (E)x(qw-jdos)x(exp[(E-Etr)/kT])x(qw-ex.Enh)*(Symm.Urbach-brdng)
        var indeX1=fileCont.indexOf('Header:');
        var indeX2=fileCont.indexOf('Parameters:');
        try {
            if (indeX1 < 0 || indeX2 < 0) {
                throw "Error in simulation settings file";
                return;
            }
            var prms = fileCont.substring(indeX2 + 11, (fileCont.length));
            prms = prms.trim();
            var headeri = fileCont.substring(indeX1 + 7, (fileCont.length));
            headeri = headeri.trim();
            setSettings(prms);
            setSelections(headeri);
            setChkboxes();
            setLegend();       //set graph legend
            makespArr();       //recreate spectral array
            makeExpArrs();     //process experimental arrays
            makeJdos();        //create density of states
            makeBoltz();       //recreate Boltzmann distribution
            makeSommer();
            calcInhom();
            calcHom();
            inhombr();
            hombr();
        }
        catch(err){
            alert('Error in processing simulation settings file');
        }
      }

      /**
       * Function for setting plotting options after reading local emission spectrum file
       * @function
       * @header {string} receives the selected options
       */
      function setSelections(header){
        //console.log('header: ',header);
        //(E)x(qw-jdos)x(exp[(E-Etr)/kT])x(qw-ex.Enh)*(Symm.Urbach-brdng)
        inhomSpectr.inPlot.eV=(header.indexOf('(E)')>=0)? true:false; //photon energy
        inhomSpectr.inPlot.jdos= (header.indexOf('(qw-jdos)')>=0)? true: false; //density of states
        inhomSpectr.inPlot.fcv= (header.indexOf('(exp[(E-Etr)/kT])')>= 0)?  true: false; //state occupancy
        inhomSpectr.inPlot.Se= (header.indexOf('(qw-ex.Enh)') >= 0)? true: false; //exiton enhancement
        inhomSpectr.inPlot.convo = false; //inhomog convolution
        inhomSpectr.inPlot.Lurb = false;  //single sided urbach
        inhomSpectr.inPlot.Lsurb = false; //two sided urbach
        inhomSpectr.inPlot.Lgaus = false; //Gaussian distrib
        inhomSpectr.inPlot.Lsech = false; //sech^n(t/tau/n) relaxation function broadening
        homSpectr.inPlot.convo=false;
        $('#pltHomConv').prop('checked',false);
        $('#pltDlorentz').prop('checked',false);
        $('#pltLorentz').prop('checked',false);
        //if(document.getElementById('box').checked)
        if (header.indexOf('*(Asym.Urbach-brdng)') >= 0) {
          inhomSpectr.inPlot.convo = true;
          inhomSpectr.inPlot.Lurb = true;
        }
        if (header.indexOf('*(Symm.Urbach-brdng)') >= 0){
          inhomSpectr.inPlot.convo = true;
          inhomSpectr.inPlot.Lsurb = true;
        }
        if (header.indexOf('*(Gaussian-brdng)') >= 0) {
          inhomSpectr.inPlot.convo = true;
          inhomSpectr.inPlot.Lgaus = true;
        }
        if (header.indexOf('*(Sech^n(t/tau/n)-brdng)') >= 0) {
          inhomSpectr.inPlot.convo = true;
          inhomSpectr.inPlot.Lsech = true;
        }
        if (header.indexOf('*(Lorentzian brdng)') >= 0) {
          console.log('*(Lorentzian brdng)',header.indexOf('*(Lorentzian brdng)')) ;
          homSpectr.inPlot.convo = true;
          $('#pltHomConv').prop('checked', true);
          $('#pltLorentz').prop('checked', true);
        }
        if(header.indexOf('*(Lorentzian1 x Lorentzian2 brdng)') >= 0){
          console.log('*(Lorentzian1 x Lorentzian2 brdng)',header.indexOf('*(Lorentzian1 x Lorentzian2 brdng)')) ;
          homSpectr.inPlot.convo=true;
          $('#pltHomConv').prop('checked',true);
          $('#pltDlorentz').prop('checked',true);
        }
      }

      /**
       * Function for setting calculation parameters after reading local emission spectrum file
       * @function
       * @parSettn {string} receives the selected options
       */
      function setSettings(parSettns) {
        //console.log('Inhomog simulation parSettns: ',parSettns);
        //parSettns: {"Estart":1.3,"Estop":1.7,"Etr":1.4,"jdos":"qw",
        // "exiton":{"Eb_meV":5,"type":"QW-2D","viewDir":"parallel","polarizat":"TE"},
        // "Boltzmann":{"Epeak_eV":1.4,"Temp_K":293},"InhmgBrdng":{"type":"SymmUrbach","Eu_meV":8}}
        var objSettns=JSON.parse(parSettns);
        simSettn.eVstart=objSettns.Estart;
        //$('#eVStart').val(objSettns.Estart);
        simSettn.eVstop=objSettns.Estop;
        //$('#eVStop').val(objSettns.Estop);
        simSettn.eTr=objSettns.Etr;
        $('#eV_Et').val(objSettns.Etr);
        simSettn.jdostype = (objSettns.jdos && objSettns.jdos=='qw')?  'qw' : 'bulk';
        if (objSettns.exiton) {
          simSettn.exEb= objSettns.exiton.Eb_meV;
          $("#eV_Bind").val(objSettns.exiton.Eb_meV);
          if (objSettns.exiton.type=="QW-2D"){
            simSettn.viewDir=objSettns.exiton.viewDir;
            if (objSettns.exiton.viewDir=='parallel'){
              $('#dirPar').prop('checked',true);
            }else{
              $('#dirPerp').prop('checked',true);
            }
            simSettn.polarizat=objSettns.exiton.polarizat;
            if (objSettns.exiton.polarizat=='TM'){
              simSettn.ex0=objSettns.exiton.shapePar;
              $("#eV_0").val(simSettn.ex0);
              $("enhTM").prop('checked',true);
            }else{
              $("enhTE").prop('checked',true);
            }
          }
        }
        if (objSettns.Boltzmann) simSettn.kelvin=objSettns.Boltzmann.Temp_K;
        if (objSettns.InhmgBrdng) {
           if (objSettns.InhmgBrdng.type=="SymmUrbach" || objSettns.InhmgBrdng.type=="AsymUrbach") {
             simSettn.eU=objSettns.InhmgBrdng.Eu_meV;
             $("#eveu, #evSeu").val(objSettns.InhmgBrdng.Eu_meV);
           }
           if (objSettns.InhmgBrdng.type == "Gaussian") {
             simSettn.GauSig = objSettns.InhmgBrdng.sigma_meV;
             $("#gauSig").val(objSettns.InhmgBrdng.sigma_meV);
           }
           if (objSettns.InhmgBrdng.type == "Sech^n(t/tau)") {
             simSettn.SechTau = objSettns.InhmgBrdng.tau_fs;
             simSettn.SechN = objSettns.InhmgBrdng.n;
             $("#sechTau").val(objSettns.InhmgBrdng.tau_fs);
             $("#sechN").val(objSettns.InhmgBrdng.n);
           }
        }
        if (objSettns.HomogBrdng){ //arvot ovat saatavilla
          if (objSettns.HomogBrdng.type=='Lorentz X Lorentz'){
            simSettn.DlTau1=objSettns.HomogBrdng.tau1_fs;
            $('#pltDlorentz').prop('checked',true);
            $('#pltLorentz').prop('checked',false);
            $("#tauBe").val(simSettn.DlTau1); //spinneri 1
            simSettn.DlTau2=objSettns.HomogBrdng.tau2_fs;
            $("#tauBh").val(simSettn.DlTau2); //spinneri 2
          }
          if (objSettns.HomogBrdng.type == 'Lorentz') {
            simSettn.LorTau = objSettns.HomogBrdng.tau_fs;
            $('#pltLorentz').prop('checked', true);
            $('#pltDlorentz').prop('checked', false);
            $("#tauR").val(simSettn.LorTau);
          }
        }
      }

      function gotHomogSim(filecont) {
          console.log('Homog simulation parameters: '),filecont ;
          //alert('gotHomogSim function not ready');
      }

      function makeEmisArr(resObj) {
          var emisArrs = resObj.datArrs; //is an object (javascript copies by reference)
          var emArr = [];
          var oneRow = [resObj.unit, 'Intensity', resObj.description];
          //becomes: eV, Intensity, File description text
          emArr.push(oneRow);
          var absc = emisArrs[0].eVs;
          var intens = emisArrs[1].Inte;
          var numPoints = absc.length;
          for (var i = 0; i < numPoints; i++) {
              oneRow = [];
              oneRow.push(absc[i]);
              oneRow.push(intens[i]);
              emArr.push(oneRow);
          }
          return emArr;
      }

      /**********************
       * Function emisSettn collects calculation settings for file saving
       * @resObj  object returned from mongodb
       * @function
       */
      function emisSettn(){
        var settings;
      }



